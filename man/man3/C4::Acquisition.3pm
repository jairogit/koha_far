.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "C4::Acquisition 3"
.TH C4::Acquisition 3 "2015-11-02" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Acquisition \- Koha functions for dealing with orders and acquisitions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use C4::Acquisition;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module deal with acquisitions, managing book
orders, basket and parcels.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1BASKETS\s0"
.IX Subsection "FUNCTIONS ABOUT BASKETS"
\fIGetBasket\fR
.IX Subsection "GetBasket"
.PP
.Vb 1
\&  $aqbasket = &GetBasket($basketnumber);
.Ve
.PP
get all basket informations in aqbasket for a given basket
.PP
\&\fBreturns:\fR informations for a given basket returned as a hashref.
.PP
\fINewBasket\fR
.IX Subsection "NewBasket"
.PP
.Vb 2
\&  $basket = &NewBasket( $booksellerid, $authorizedby, $basketname, 
\&      $basketnote, $basketbooksellernote, $basketcontractnumber, $deliveryplace, $billingplace );
.Ve
.PP
Create a new basket in aqbasket table
.ie n .IP "$booksellerid is a foreign key in the aqbasket table" 4
.el .IP "\f(CW$booksellerid\fR is a foreign key in the aqbasket table" 4
.IX Item "$booksellerid is a foreign key in the aqbasket table"
.PD 0
.ie n .IP "$authorizedby is the username of who created the basket" 4
.el .IP "\f(CW$authorizedby\fR is the username of who created the basket" 4
.IX Item "$authorizedby is the username of who created the basket"
.PD
.PP
The other parameters are optional, see ModBasketHeader for more info on them.
.PP
\fICloseBasket\fR
.IX Subsection "CloseBasket"
.PP
.Vb 1
\&  &CloseBasket($basketno);
.Ve
.PP
close a basket (becomes unmodifiable, except for receives)
.PP
\fIReopenBasket\fR
.IX Subsection "ReopenBasket"
.PP
.Vb 1
\&  &ReopenBasket($basketno);
.Ve
.PP
reopen a basket
.PP
\fIGetBasketAsCSV\fR
.IX Subsection "GetBasketAsCSV"
.PP
.Vb 1
\&  &GetBasketAsCSV($basketno);
.Ve
.PP
Export a basket as \s-1CSV\s0
.PP
\&\f(CW$cgi\fR parameter is needed for column name translation
.PP
\fIGetBasketGroupAsCSV\fR
.IX Subsection "GetBasketGroupAsCSV"
.Sp
.RS 4
&GetBasketGroupAsCSV($basketgroupid);
.Sp
Export a basket group as \s-1CSV\s0
.Sp
\&\f(CW$cgi\fR parameter is needed for column name translation
.RE
.PP
\fICloseBasketgroup\fR
.IX Subsection "CloseBasketgroup"
.PP
.Vb 1
\&  &CloseBasketgroup($basketgroupno);
.Ve
.PP
close a basketgroup
.PP
\fIReOpenBaskergroup($basketgroupno)\fR
.IX Subsection "ReOpenBaskergroup($basketgroupno)"
.PP
.Vb 1
\&  &ReOpenBaskergroup($basketgroupno);
.Ve
.PP
reopen a basketgroup
.PP
\fIDelBasket\fR
.IX Subsection "DelBasket"
.PP
.Vb 1
\&  &DelBasket($basketno);
.Ve
.PP
Deletes the basket that has basketno field \f(CW$basketno\fR in the aqbasket table.
.ie n .IP "$basketno is the primary key of the basket in the aqbasket table." 4
.el .IP "\f(CW$basketno\fR is the primary key of the basket in the aqbasket table." 4
.IX Item "$basketno is the primary key of the basket in the aqbasket table."
.PP
\fIModBasket\fR
.IX Subsection "ModBasket"
.PP
.Vb 1
\&  &ModBasket($basketinfo);
.Ve
.PP
Modifies a basket, using a hashref \f(CW$basketinfo\fR for the relevant information, only \f(CW$basketinfo\fR\->{'basketno'} is required.
.ie n .IP "$basketno is the primary key of the basket in the aqbasket table." 4
.el .IP "\f(CW$basketno\fR is the primary key of the basket in the aqbasket table." 4
.IX Item "$basketno is the primary key of the basket in the aqbasket table."
.PP
\fIModBasketHeader\fR
.IX Subsection "ModBasketHeader"
.PP
.Vb 1
\&  &ModBasketHeader($basketno, $basketname, $note, $booksellernote, $contractnumber, $booksellerid);
.Ve
.PP
Modifies a basket's header.
.ie n .IP "$basketno is the ""basketno"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$basketno\fR is the ``basketno'' field in the ``aqbasket'' table;" 4
.IX Item "$basketno is the basketno field in the aqbasket table;"
.PD 0
.ie n .IP "$basketname is the ""basketname"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$basketname\fR is the ``basketname'' field in the ``aqbasket'' table;" 4
.IX Item "$basketname is the basketname field in the aqbasket table;"
.ie n .IP "$note is the ""note"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$note\fR is the ``note'' field in the ``aqbasket'' table;" 4
.IX Item "$note is the note field in the aqbasket table;"
.ie n .IP "$booksellernote is the ""booksellernote"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$booksellernote\fR is the ``booksellernote'' field in the ``aqbasket'' table;" 4
.IX Item "$booksellernote is the booksellernote field in the aqbasket table;"
.ie n .IP "$contractnumber is the ""contractnumber"" (foreign) key in the ""aqbasket"" table." 4
.el .IP "\f(CW$contractnumber\fR is the ``contractnumber'' (foreign) key in the ``aqbasket'' table." 4
.IX Item "$contractnumber is the contractnumber (foreign) key in the aqbasket table."
.ie n .IP "$booksellerid is the id (foreign) key in the ""aqbooksellers"" table for the vendor." 4
.el .IP "\f(CW$booksellerid\fR is the id (foreign) key in the ``aqbooksellers'' table for the vendor." 4
.IX Item "$booksellerid is the id (foreign) key in the aqbooksellers table for the vendor."
.ie n .IP "$deliveryplace is the ""deliveryplace"" field in the aqbasket table." 4
.el .IP "\f(CW$deliveryplace\fR is the ``deliveryplace'' field in the aqbasket table." 4
.IX Item "$deliveryplace is the deliveryplace field in the aqbasket table."
.ie n .IP "$billingplace is the ""billingplace"" field in the aqbasket table." 4
.el .IP "\f(CW$billingplace\fR is the ``billingplace'' field in the aqbasket table." 4
.IX Item "$billingplace is the billingplace field in the aqbasket table."
.PD
.PP
\fIGetBasketsByBookseller\fR
.IX Subsection "GetBasketsByBookseller"
.PP
.Vb 1
\&  @results = &GetBasketsByBookseller($booksellerid, $extra);
.Ve
.PP
Returns a list of hashes of all the baskets that belong to bookseller 'booksellerid'.
.ie n .IP "$booksellerid is the 'id' field of the bookseller in the aqbooksellers table" 4
.el .IP "\f(CW$booksellerid\fR is the 'id' field of the bookseller in the aqbooksellers table" 4
.IX Item "$booksellerid is the 'id' field of the bookseller in the aqbooksellers table"
.PD 0
.ie n .IP "$extra is the extra sql parameters, can be" 4
.el .IP "\f(CW$extra\fR is the extra sql parameters, can be" 4
.IX Item "$extra is the extra sql parameters, can be"
.PD
.Vb 4
\& $extra\->{groupby}: group baskets by column
\&    ex. $extra\->{groupby} = aqbasket.basketgroupid
\& $extra\->{orderby}: order baskets by column
\& $extra\->{limit}: limit number of results (can be helpful for pagination)
.Ve
.PP
\fIGetBasketsInfosByBookseller\fR
.IX Subsection "GetBasketsInfosByBookseller"
.PP
.Vb 1
\&    my $baskets = GetBasketsInfosByBookseller($supplierid, $allbaskets);
.Ve
.PP
The optional second parameter allbaskets is a boolean allowing you to
select all baskets from the supplier; by default only active baskets (open or 
closed but still something to receive) are returned.
.PP
Returns in a arrayref of hashref all about booksellers baskets, plus:
    total_biblios: Number of distinct biblios in basket
    total_items: Number of items in basket
    expected_items: Number of non-received items in basket
.PP
\fIGetBasketUsers\fR
.IX Subsection "GetBasketUsers"
.PP
.Vb 1
\&    $basketusers_ids = &GetBasketUsers($basketno);
.Ve
.PP
Returns a list of all borrowernumbers that are in basket users list
.PP
\fIModBasketUsers\fR
.IX Subsection "ModBasketUsers"
.PP
.Vb 2
\&    my @basketusers_ids = (1, 2, 3);
\&    &ModBasketUsers($basketno, @basketusers_ids);
.Ve
.PP
Delete all users from basket users list, and add users in \f(CW@basketusers_ids\fR
to this users list.
.PP
\fICanUserManageBasket\fR
.IX Subsection "CanUserManageBasket"
.PP
.Vb 2
\&    my $bool = CanUserManageBasket($borrower, $basket[, $userflags]);
\&    my $bool = CanUserManageBasket($borrowernumber, $basketno[, $userflags]);
.Ve
.PP
Check if a borrower can manage a basket, according to system preference
AcqViewBaskets, user permissions and basket properties (creator, users list,
branch).
.PP
First parameter can be either a borrowernumber or a hashref as returned by
C4::Members::GetMember.
.PP
Second parameter can be either a basketno or a hashref as returned by
C4::Acquisition::GetBasket.
.PP
The third parameter is optional. If given, it should be a hashref as returned
by C4::Auth::getuserflags. If not, getuserflags is called.
.PP
If user is authorised to manage basket, returns 1.
Otherwise returns 0.
.PP
\fIGetBasketsByBasketgroup\fR
.IX Subsection "GetBasketsByBasketgroup"
.PP
.Vb 1
\&  $baskets = &GetBasketsByBasketgroup($basketgroupid);
.Ve
.PP
Returns a reference to all baskets that belong to basketgroup \f(CW$basketgroupid\fR.
.PP
\fINewBasketgroup\fR
.IX Subsection "NewBasketgroup"
.PP
.Vb 1
\&  $basketgroupid = NewBasketgroup(\e%hashref);
.Ve
.PP
Adds a basketgroup to the aqbasketgroups table, and add the initial baskets to it.
.PP
\&\f(CW$hashref\fR\->{'booksellerid'} is the 'id' field of the bookseller in the aqbooksellers table,
.PP
\&\f(CW$hashref\fR\->{'name'} is the 'name' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'basketlist'} is a list reference of the 'id's of the baskets that belong to this group,
.PP
\&\f(CW$hashref\fR\->{'billingplace'} is the 'billingplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliveryplace'} is the 'deliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'freedeliveryplace'} is the 'freedeliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliverycomment'} is the 'deliverycomment' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'closed'} is the 'closed' field of the aqbasketgroups table, it is false if 0, true otherwise.
.PP
\fIModBasketgroup\fR
.IX Subsection "ModBasketgroup"
.PP
.Vb 1
\&  ModBasketgroup(\e%hashref);
.Ve
.PP
Modifies a basketgroup in the aqbasketgroups table, and add the baskets to it.
.PP
\&\f(CW$hashref\fR\->{'id'} is the 'id' field of the basketgroup in the aqbasketgroup table, this parameter is mandatory,
.PP
\&\f(CW$hashref\fR\->{'name'} is the 'name' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'basketlist'} is a list reference of the 'id's of the baskets that belong to this group,
.PP
\&\f(CW$hashref\fR\->{'billingplace'} is the 'billingplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliveryplace'} is the 'deliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'freedeliveryplace'} is the 'freedeliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliverycomment'} is the 'deliverycomment' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'closed'} is the 'closed' field of the aqbasketgroups table, it is false if 0, true otherwise.
.PP
\fIDelBasketgroup\fR
.IX Subsection "DelBasketgroup"
.PP
.Vb 1
\&  DelBasketgroup($basketgroupid);
.Ve
.PP
Deletes a basketgroup in the aqbasketgroups table, and removes the reference to it from the baskets,
.ie n .IP "$basketgroupid is the 'id' field of the basket in the aqbasketgroup table" 4
.el .IP "\f(CW$basketgroupid\fR is the 'id' field of the basket in the aqbasketgroup table" 4
.IX Item "$basketgroupid is the 'id' field of the basket in the aqbasketgroup table"
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1ORDERS\s0"
.IX Subsection "FUNCTIONS ABOUT ORDERS"
\fIGetBasketgroup\fR
.IX Subsection "GetBasketgroup"
.PP
.Vb 1
\&  $basketgroup = &GetBasketgroup($basketgroupid);
.Ve
.PP
Returns a reference to the hash containing all information about the basketgroup.
.PP
\fIGetBasketgroups\fR
.IX Subsection "GetBasketgroups"
.PP
.Vb 1
\&  $basketgroups = &GetBasketgroups($booksellerid);
.Ve
.PP
Returns a reference to the array of all the basketgroups of bookseller \f(CW$booksellerid\fR.
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1ORDERS\s0"
.IX Subsection "FUNCTIONS ABOUT ORDERS"
\fIGetOrders\fR
.IX Subsection "GetOrders"
.PP
.Vb 1
\&  @orders = &GetOrders($basketnumber, $orderby);
.Ve
.PP
Looks up the pending (non-cancelled) orders with the given basket
number. If \f(CW$booksellerID\fR is non-empty, only orders from that seller
are returned.
.PP
return :
\&\f(CW&basket\fR returns a two-element array. \f(CW@orders\fR is an array of
references-to-hash, whose keys are the fields from the aqorders,
biblio, and biblioitems tables in the Koha database.
.PP
\fIGetOrdersByBiblionumber\fR
.IX Subsection "GetOrdersByBiblionumber"
.PP
.Vb 1
\&  @orders = &GetOrdersByBiblionumber($biblionumber);
.Ve
.PP
Looks up the orders with linked to a specific \f(CW$biblionumber\fR, including
cancelled orders and received orders.
.PP
return :
\&\f(CW@orders\fR is an array of references-to-hash, whose keys are the
fields from the aqorders, biblio, and biblioitems tables in the Koha database.
.PP
\fIGetOrder\fR
.IX Subsection "GetOrder"
.PP
.Vb 1
\&  $order = &GetOrder($ordernumber);
.Ve
.PP
Looks up an order by order number.
.PP
Returns a reference-to-hash describing the order. The keys of
\&\f(CW$order\fR are fields from the biblio, biblioitems, aqorders tables of the Koha database.
.PP
\fIGetLastOrderNotReceivedFromSubscriptionid\fR
.IX Subsection "GetLastOrderNotReceivedFromSubscriptionid"
.PP
.Vb 1
\&  $order = &GetLastOrderNotReceivedFromSubscriptionid($subscriptionid);
.Ve
.PP
Returns a reference-to-hash describing the last order not received for a subscription.
.PP
\fIGetLastOrderReceivedFromSubscriptionid\fR
.IX Subsection "GetLastOrderReceivedFromSubscriptionid"
.PP
.Vb 1
\&  $order = &GetLastOrderReceivedFromSubscriptionid($subscriptionid);
.Ve
.PP
Returns a reference-to-hash describing the last order received for a subscription.
.PP
\fIModOrder\fR
.IX Subsection "ModOrder"
.PP
.Vb 1
\&  &ModOrder(\e%hashref);
.Ve
.PP
Modifies an existing order. Updates the order with order number
\&\f(CW$hashref\fR\->{'ordernumber'} and biblionumber \f(CW$hashref\fR\->{'biblionumber'}. All 
other keys of the hash update the fields with the same name in the aqorders 
table of the Koha database.
.PP
\fIModItemOrder\fR
.IX Subsection "ModItemOrder"
.PP
.Vb 1
\&    ModItemOrder($itemnumber, $ordernumber);
.Ve
.PP
Modifies the ordernumber of an item in aqorders_items.
.PP
\fIGetCancelledOrders\fR
.IX Subsection "GetCancelledOrders"
.PP
.Vb 1
\&  my @orders = GetCancelledOrders($basketno, $orderby);
.Ve
.PP
Returns cancelled orders for a basket
.PP
\fIModReceiveOrder\fR
.IX Subsection "ModReceiveOrder"
.PP
.Vb 10
\&  &ModReceiveOrder({
\&    biblionumber => $biblionumber,
\&    ordernumber => $ordernumber,
\&    quantityreceived => $quantityreceived,
\&    user => $user,
\&    cost => $cost,
\&    ecost => $ecost,
\&    invoiceid => $invoiceid,
\&    rrp => $rrp,
\&    budget_id => $budget_id,
\&    datereceived => $datereceived,
\&    received_itemnumbers => \e@received_itemnumbers,
\&    order_internalnote => $order_internalnote,
\&    order_vendornote => $order_vendornote,
\&   });
.Ve
.PP
Updates an order, to reflect the fact that it was received, at least
in part. All arguments not mentioned below update the fields with the
same name in the aqorders table of the Koha database.
.PP
If a partial order is received, splits the order into two.
.PP
Updates the order with bibilionumber \f(CW$biblionumber\fR and ordernumber
\&\f(CW$ordernumber\fR.
.PP
\fICancelReceipt\fR
.IX Subsection "CancelReceipt"
.PP
.Vb 1
\&    my $parent_ordernumber = CancelReceipt($ordernumber);
\&
\&    Cancel an order line receipt and update the parent order line, as if no
\&    receipt was made.
\&    If items are created at receipt (AcqCreateItem = receiving) then delete
\&    these items.
.Ve
.PP
\fISearchOrders\fR
.IX Subsection "SearchOrders"
.PP
\&\f(CW@results\fR = &SearchOrders({
    ordernumber => \f(CW$ordernumber\fR,
    search => \f(CW$search\fR,
    biblionumber => \f(CW$biblionumber\fR,
    ean => \f(CW$ean\fR,
    booksellerid => \f(CW$booksellerid\fR,
    basketno => \f(CW$basketno\fR,
    owner => \f(CW$owner\fR,
    pending => \f(CW$pending\fR
    ordered => \f(CW$ordered\fR
});
.PP
Searches for orders.
.PP
\&\f(CW$owner\fR Finds order for the logged in user.
\&\f(CW$pending\fR Finds pending orders. Ignores completed and cancelled orders.
\&\f(CW$ordered\fR Finds orders to receive only (status 'ordered' or 'partial').
.PP
\&\f(CW@results\fR is an array of references-to-hash with the keys are fields
from aqorders, biblio, biblioitems and aqbasket tables.
.PP
\fIDelOrder\fR
.IX Subsection "DelOrder"
.PP
.Vb 1
\&  &DelOrder($biblionumber, $ordernumber);
.Ve
.PP
Cancel the order with the given order and biblio numbers. It does not
delete any entries in the aqorders table, it merely marks them as
cancelled.
.PP
\fITransferOrder\fR
.IX Subsection "TransferOrder"
.PP
.Vb 1
\&    my $newordernumber = TransferOrder($ordernumber, $basketno);
.Ve
.PP
Transfer an order line to a basket.
Mark \f(CW$ordernumber\fR as cancelled with an internal note 'Cancelled and transfered
to \s-1BOOKSELLER\s0 on \s-1DATE\s0' and create new order with internal note
\&'Transfered from \s-1BOOKSELLER\s0 on \s-1DATE\s0'.
Move all attached items to the new order.
Received orders cannot be transfered.
Return the ordernumber of created order.
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1PARCELS\s0"
.IX Subsection "FUNCTIONS ABOUT PARCELS"
\fIGetParcel\fR
.IX Subsection "GetParcel"
.PP
.Vb 1
\&  @results = &GetParcel($booksellerid, $code, $date);
.Ve
.PP
Looks up all of the received items from the supplier with the given
bookseller \s-1ID\s0 at the given date, for the given code (bookseller Invoice number). Ignores cancelled and completed orders.
.PP
\&\f(CW@results\fR is an array of references-to-hash. The keys of each element are fields from
the aqorders, biblio, and biblioitems tables of the Koha database.
.PP
\&\f(CW@results\fR is sorted alphabetically by book title.
.PP
\fIGetParcels\fR
.IX Subsection "GetParcels"
.PP
.Vb 1
\&  $results = &GetParcels($bookseller, $order, $code, $datefrom, $dateto);
.Ve
.PP
get a lists of parcels.
.PP
* Input arg :
.ie n .IP "$bookseller is the bookseller this function has to get parcels." 4
.el .IP "\f(CW$bookseller\fR is the bookseller this function has to get parcels." 4
.IX Item "$bookseller is the bookseller this function has to get parcels."
.PD 0
.ie n .IP "$order To know on what criteria the results list has to be ordered." 4
.el .IP "\f(CW$order\fR To know on what criteria the results list has to be ordered." 4
.IX Item "$order To know on what criteria the results list has to be ordered."
.ie n .IP "$code is the booksellerinvoicenumber." 4
.el .IP "\f(CW$code\fR is the booksellerinvoicenumber." 4
.IX Item "$code is the booksellerinvoicenumber."
.ie n .IP "$datefrom & $dateto to know on what date this function has to filter its search." 4
.el .IP "\f(CW$datefrom\fR & \f(CW$dateto\fR to know on what date this function has to filter its search." 4
.IX Item "$datefrom & $dateto to know on what date this function has to filter its search."
.PD
.PP
* return:
a pointer on a hash list containing parcel informations as such :
.IP "Creation date" 4
.IX Item "Creation date"
.PD 0
.IP "Last operation" 4
.IX Item "Last operation"
.IP "Number of biblio" 4
.IX Item "Number of biblio"
.IP "Number of items" 4
.IX Item "Number of items"
.PD
.PP
\fIGetLateOrders\fR
.IX Subsection "GetLateOrders"
.PP
.Vb 1
\&  @results = &GetLateOrders;
.Ve
.PP
Searches for bookseller with late orders.
.PP
return:
the table of supplier with late issues. This table is full of hashref.
.PP
\fIGetHistory\fR
.IX Subsection "GetHistory"
.PP
.Vb 1
\&  \e@order_loop = GetHistory( %params );
.Ve
.PP
Retreives some acquisition history information
.PP
params:  
  title
  author
  name
  isbn
  ean
  from_placed_on
  to_placed_on
  basket                  \- search both basket name and number
  booksellerinvoicenumber 
  basketgroupname
  budget
  orderstatus (note that orderstatus '' will retrieve orders
               of any status except cancelled)
  biblionumber
  get_canceled_order (if set to a true value, cancelled orders will
                      be included)
.PP
returns:
    \f(CW$order_loop\fR is a list of hashrefs that each look like this:
            {
                'author'           => 'Twain, Mark',
                'basketno'         => '1',
                'biblionumber'     => '215',
                'count'            => 1,
                'creationdate'     => '\s-1MM/DD/YYYY\s0',
                'datereceived'     => undef,
                'ecost'            => '1.00',
                'id'               => '1',
                'invoicenumber'    => undef,
                'name'             => '',
                'ordernumber'      => '1',
                'quantity'         => 1,
                'quantityreceived' => undef,
                'title'            => 'The Adventures of Huckleberry Finn'
            }
.SS "GetRecentAcqui"
.IX Subsection "GetRecentAcqui"
.Vb 1
\&  $results = GetRecentAcqui($days);
.Ve
.PP
\&\f(CW$results\fR is a ref to a table which containts hashref
.PP
\fIAddClaim\fR
.IX Subsection "AddClaim"
.Sp
.RS 4
&AddClaim($ordernumber);
.Sp
Add a claim for an order
.RE
.PP
\fIGetInvoices\fR
.IX Subsection "GetInvoices"
.PP
.Vb 10
\&    my @invoices = GetInvoices(
\&        invoicenumber => $invoicenumber,
\&        supplierid => $supplierid,
\&        suppliername => $suppliername,
\&        shipmentdatefrom => $shipmentdatefrom, # ISO format
\&        shipmentdateto => $shipmentdateto, # ISO format
\&        billingdatefrom => $billingdatefrom, # ISO format
\&        billingdateto => $billingdateto, # ISO format
\&        isbneanissn => $isbn_or_ean_or_issn,
\&        title => $title,
\&        author => $author,
\&        publisher => $publisher,
\&        publicationyear => $publicationyear,
\&        branchcode => $branchcode,
\&        order_by => $order_by
\&    );
.Ve
.PP
Return a list of invoices that match all given criteria.
.PP
\&\f(CW$order_by\fR is \*(L"column_name (asc|desc)\*(R", where column_name is any of
\&'invoicenumber', 'booksellerid', 'shipmentdate', 'billingdate', 'closedate',
\&'shipmentcost', 'shipmentcost_budgetid'.
.PP
asc is the default if omitted
.PP
\fIGetInvoice\fR
.IX Subsection "GetInvoice"
.PP
.Vb 1
\&    my $invoice = GetInvoice($invoiceid);
.Ve
.PP
Get informations about invoice with given \f(CW$invoiceid\fR
.PP
Return a hash filled with aqinvoices.* fields
.PP
\fIGetInvoiceDetails\fR
.IX Subsection "GetInvoiceDetails"
.PP
.Vb 1
\&    my $invoice = GetInvoiceDetails($invoiceid)
.Ve
.PP
Return informations about an invoice + the list of related order lines
.PP
Orders informations are in \f(CW$invoice\fR\->{orders} (array ref)
.PP
\fIAddInvoice\fR
.IX Subsection "AddInvoice"
.PP
.Vb 9
\&    my $invoiceid = AddInvoice(
\&        invoicenumber => $invoicenumber,
\&        booksellerid => $booksellerid,
\&        shipmentdate => $shipmentdate,
\&        billingdate => $billingdate,
\&        closedate => $closedate,
\&        shipmentcost => $shipmentcost,
\&        shipmentcost_budgetid => $shipmentcost_budgetid
\&    );
.Ve
.PP
Create a new invoice and return its id or undef if it fails.
.PP
\fIModInvoice\fR
.IX Subsection "ModInvoice"
.PP
.Vb 10
\&    ModInvoice(
\&        invoiceid => $invoiceid,    # Mandatory
\&        invoicenumber => $invoicenumber,
\&        booksellerid => $booksellerid,
\&        shipmentdate => $shipmentdate,
\&        billingdate => $billingdate,
\&        closedate => $closedate,
\&        shipmentcost => $shipmentcost,
\&        shipmentcost_budgetid => $shipmentcost_budgetid
\&    );
.Ve
.PP
Modify an invoice, invoiceid is mandatory.
.PP
Return undef if it fails.
.PP
\fICloseInvoice\fR
.IX Subsection "CloseInvoice"
.PP
.Vb 1
\&    CloseInvoice($invoiceid);
.Ve
.PP
Close an invoice.
.PP
Equivalent to ModInvoice(invoiceid => \f(CW$invoiceid\fR, closedate => undef);
.PP
\fIReopenInvoice\fR
.IX Subsection "ReopenInvoice"
.PP
.Vb 1
\&    ReopenInvoice($invoiceid);
.Ve
.PP
Reopen an invoice
.PP
Equivalent to ModInvoice(invoiceid => \f(CW$invoiceid\fR, closedate => C4::Dates\->\fInew()\fR\->output('iso'))
.PP
\fIDelInvoice\fR
.IX Subsection "DelInvoice"
.PP
.Vb 1
\&    DelInvoice($invoiceid);
.Ve
.PP
Delete an invoice if there are no items attached to it.
.PP
\fIMergeInvoices\fR
.IX Subsection "MergeInvoices"
.PP
.Vb 1
\&    MergeInvoices($invoiceid, \e@sourceids);
.Ve
.PP
Merge the invoices identified by the IDs in \e@sourceids into
the invoice identified by \f(CW$invoiceid\fR.
.PP
\fIGetBiblioCountByBasketno\fR
.IX Subsection "GetBiblioCountByBasketno"
.PP
\&\f(CW$biblio_count\fR = &GetBiblioCountByBasketno($basketno);
.PP
Looks up the biblio's count that has basketno value \f(CW$basketno\fR
.PP
Returns a quantity
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
